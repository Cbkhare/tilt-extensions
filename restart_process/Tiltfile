TYPE_RESTART_CONTAINER_STEP = 'live_update_restart_container_step'

KWARGS_BLACKLIST = [
    # since we'll be passing `dockerfile_contents` when building the
    # child image, remove any kwargs that might conflict
    'dockerfile', 'dockerfile_contents',

    # 'target' isn't relevant to our child build--if we pass this arg,
    # Docker will just fail to find the specified stage and error out
    'target',
]


def docker_build_with_restart(ref, context, entrypoint, live_update,
                              base_suffix='-base', shell_path=None, **kwargs):
    """Wrap a docker_build call and its associated live_update steps so that the last step
    of any live update is to rerun the given entrypoint.

     Args:
      ref: name for this image (e.g. 'myproj/backend' or 'myregistry/myproj/backend'); as the parameter of the same name in docker_build
      context: path to use as the Docker build context; as the parameter of the same name in docker_build
      entrypoint: the command to be (re-)executed when the container starts or when a live_update is run
      live_update: set of steps for updating a running container; as the parameter of the same name in docker_build
      base_suffix: suffix for naming the base image, applied as {ref}{base_suffix}
      shell_path: the path to the container's shell, if not found by shebang "#!usr/bin/env sh"
      **kwargs: will be passed to the underlying `docker_build` call
    """
    # first, validate the given live_update steps
    if len(live_update) == 0:
        fail("`docker_build_with_restart` requires at least one live_update step")
    for step in live_update:
        if type(step) == TYPE_RESTART_CONTAINER_STEP:
            fail("`docker_build_with_restart` is not compatible with live_update step: "+
                 "`restart_container()` (this extension is meant to REPLACE restart_container() )")

    # rename the original image to make it a base image and declare a docker_build for it
    base_ref = '{}{}'.format(ref, base_suffix)
    docker_build(base_ref, context, **kwargs)

    # declare a new docker build that adds Tilt's process wrapper scripts to the user's image
    # TODO(maia): should the name of the `scripts-helper` image be configurable?
    df = '''
    FROM tiltdev/restart-scripts:2020-22-04 as scripts-helper

    FROM {}
    COPY --from=scripts-helper /start.sh /
    COPY --from=scripts-helper /restart.sh /
  '''.format(base_ref)

    # Clean kwargs for building the child image (which builds on user's specified image
    # and copies in some scripts). In practice, this means removing kwargs that were
    # relevant to building the user's specified image but are NOT relevant to building
    # the child image / may conflict with args we specifically pass for the child image.
    cleaned_kwargs = {k: v for k, v in kwargs.items() if k not in KWARGS_BLACKLIST}

    # Override this image's command to execute the given entrypoint via `start.sh`
    # (this allows us to later RE-execute the process by running `restart.sh`)
    if type(entrypoint) == type(""):
        entrypoint_with_start_sh = ["/start.sh", entrypoint]
    elif type(entrypoint) == type([]):
        entrypoint_with_start_sh = ["/start.sh"] + entrypoint
    else:
        fail("`entrypoint` must be a string or list of strings: got {}".format(type(entrypoint)))

    if shell_path:
        entrypoint_with_start_sh = [shell_path] + entrypoint_with_start_sh

    # last live_update step is to run `restart.sh`, which re-executes the given entrypoint
    restart_cmd = "/restart.sh"
    if shell_path:
        restart_cmd = "{} {}".format(shell_path, restart_cmd)
    live_update = live_update + [run(restart_cmd)]

    docker_build(ref, context, entrypoint=entrypoint_with_start_sh, dockerfile_contents=df,
                 live_update=live_update, **cleaned_kwargs)
